<?xml version="1.0" ?>
<cherrytree>
	<node custom_icon_id="0" foreground="" is_bold="True" name="Formation DevOps" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538577726.46" ts_lastsave="1538646508.66" unique_id="1">
		<rich_text>Penser à bien valider sa présence sur : </rich_text>
		<rich_text link="webs http://quest.ajc-formation.fr:8000">http://quest.ajc-formation.fr:8000</rich_text>
		<rich_text> (matin et après-midi).

Code wifi : 7894561230</rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Algo et Objet" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538577731.01" ts_lastsave="1539071272.95" unique_id="2">
			<rich_text scale="h1">Prof. : ASSOUS Steeve

</rich_text>
			<rich_text scale="h2">Code : 3404</rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h2">Conception d'algo :</rich_text>
			<rich_text>
    </rich_text>
			<rich_text weight="heavy">ANALYSE</rich_text>
			<rich_text> -&gt; </rich_text>
			<rich_text weight="heavy">CONCEPTION</rich_text>
			<rich_text> -&gt; </rich_text>
			<rich_text weight="heavy">PROGRAMMATION</rich_text>
			<rich_text> -&gt; </rich_text>
			<rich_text weight="heavy">TEST</rich_text>
			<rich_text>
    
</rich_text>
			<rich_text scale="h2">En POO :</rich_text>
			<rich_text>
    Objet contient 3 concepts fondamentaux : 
        - </rich_text>
			<rich_text weight="heavy">polymorphysme</rich_text>
			<rich_text>
        - </rich_text>
			<rich_text weight="heavy">encapsulation</rich_text>
			<rich_text>
        - </rich_text>
			<rich_text weight="heavy">héritage</rich_text>
			<rich_text>
        
</rich_text>
			<rich_text scale="h2">Objets de bases :</rich_text>
			<rich_text>
    - données en entrée et résultats intermédiaires
    - régle opératoire
    - ici on parle du nom commun objet (différent de POO)
    
</rich_text>
			<rich_text scale="h3">    Un objet contient :</rich_text>
			<rich_text>
        - un </rich_text>
			<rich_text weight="heavy">identificateur</rich_text>
			<rich_text> (nom)
        - un </rich_text>
			<rich_text weight="heavy">type</rich_text>
			<rich_text> (entier, numérique, caractère ...)
        - une </rich_text>
			<rich_text weight="heavy">valeur</rich_text>
			<rich_text>
        
</rich_text>
			<rich_text scale="h2">Types simples</rich_text>
			<rich_text>
    Ce sont les </rich_text>
			<rich_text weight="heavy">caractères</rich_text>
			<rich_text>, </rich_text>
			<rich_text weight="heavy">textes</rich_text>
			<rich_text> (ou </rich_text>
			<rich_text weight="heavy">chaînes</rich_text>
			<rich_text> </rich_text>
			<rich_text weight="heavy">de</rich_text>
			<rich_text> </rich_text>
			<rich_text weight="heavy">caractères</rich_text>
			<rich_text>), </rich_text>
			<rich_text weight="heavy">logiques</rich_text>
			<rich_text>, </rich_text>
			<rich_text weight="heavy">bouléens</rich_text>
			<rich_text>, </rich_text>
			<rich_text weight="heavy">indicateurs</rich_text>
			<rich_text> et les </rich_text>
			<rich_text weight="heavy">nombres</rich_text>
			<rich_text>.

</rich_text>
			<rich_text scale="h2">Types composés</rich_text>
			<rich_text>
    Ce sont les </rich_text>
			<rich_text weight="heavy">fiichiers</rich_text>
			<rich_text> et les </rich_text>
			<rich_text weight="heavy">tableaux</rich_text>
			<rich_text>.

</rich_text>
			<rich_text scale="h2">Actions de base</rich_text>
			<rich_text>
    Elles sont : 
        - affectation : attribuer une valeur à un objet
        - affectation particulière : initialisation, incrémentation/décrémentation
        
    Ex : 
        // Debut
        
            // DECLARATION
                variable : type
                
            // INITIALISATION
                variable = 0
                
            // CORPS DU PROGRAMMES
                instruction 1
                instruction 2
                ...
                
</rich_text>
			<rich_text scale="h2">Autres actions de base</rich_text>
			<rich_text>
    - lecture : à partir du clavier / fichier
    - ecriture : écran / sur un support externe
    - concaténer : associer variable avec texte
    
</rich_text>
			<rich_text scale="h2">Choix ou Structures Conditionnelles</rich_text>
			<rich_text>
    On a le choix entre plusieurs actions :
        - structures conditionnelles pures
            ex: SI condition
                      ALORS 
                          action 1
                 FIN SI
                 
        - structures conditionnelles alternatives
            ex: SI condition
                      ALORS
                          action 1
                      SINON
                          action 2
                  FIN SI
                  
        - structures conditionnelles alternatives imbriquées
            ex: SI condition
                      ALORS
                          action 1
                      SINON
                          SI cond
                              ALORS
                                  action 2
                              SINON
                                  action 3
                          FIN SI
                  FIN SI
                  
</rich_text>
			<rich_text scale="h2">Répétition</rich_text>
			<rich_text>
    Sert à repeter n fois une action :
        - TANT QUE
        - REPETER ... JUSQU'A : effectue l'action une fois avant de vérifier la condition
        - POUR

</rich_text>
			<rich_text scale="h2">Tableaux à une dimension</rich_text>
			<rich_text>
    Ils peuvent être préremplis. 
    L'indexation commence à 0. 
    Un tableau de N case aura pour indice i de 0 à N-1.
    
</rich_text>
			<rich_text scale="h2">Tableaux à deux dimensions</rich_text>
			<rich_text>
    Lorsqu'un traitement utilisie plusieurs tableaux à une dimension, on utilisera un tableau à deux dimensions. 
    On défini T(i,j) avec i lignes et j colonnes.
    Pour lire un tableau à 2 dimensions on doit imbriquer deux boucles l'une dans l'autre :
    ex: POUR ligne DE 0 A N-1
             POUR colonne  DE 0 A M-1
                 AFF ligne, colone, T(ligne,colonne)
            FIN POUR
        FIN POUR
        
</rich_text>
			<rich_text scale="h2">Les Concepts de l'Approche par Objets</rich_text>
			<rich_text>
    3 concepts nécessaire à la POO :
        - encapsulage
        - héritage
        - polymorphisme
        
</rich_text>
			<rich_text scale="h2">Classe</rich_text>
			<rich_text>
    Une classe est un modèle qui décrit une abstraction.
    Permet de recenser une série d'éléments communs décrivant un concept précis.
    Elles décrivent les propriétés des objets.
    Analogie avec plan d'un pavillon, avec chaque pavillon qui peut avoir une couleur différente (plan = classe, pavillon = objet).
    Elles sont de 2 types :
        - propriétés contenant de l'information : 
            o modifiés au travers de la méthode
            o ces propriétés sont les &quot;attributs&quot;
        - propriétés actives
            o fournissent un service et peuvent modifier l'état d'un Objet
            o ses propriétés sont les &quot;méthodes&quot;
            
    ex: classe compte
        propriétés (attributs) : solde, decouvertAutorise, dateOuverture
        propriétés actives (méthode) : crediter(), debiter(), obtenirSolde(), calculAgios()
        
    Il est possible de conférer un type à un attribut ou à un argument d'une methode.
    Un type désigne un ensemble de valeurs que peut prendre un attribut ou un argument : entier, chaine, booléen, reel...
    Une classe peut également servir de type.
    
</rich_text>
			<rich_text scale="h2">Objet</rich_text>
			<rich_text>
    C'est une matérialisation de la classe (concrétisation).
    L'acte de concrétiser une classe s'appelle le mécanisme d'instanciation.
    On dit qu'on instancie une classe ou que l'on crée un Objet.
    Objet = instance de Classe.
    ex: MaVoiture:Automobile
        marque = “Peugeot”
        modèle = “607”
        puissance = 10
        couleur = “rouge”
        
</rich_text>
			<rich_text scale="h2">Encapsulation</rich_text>
			<rich_text>
    Pour chaque attribut et ou méthode d'une classe, on précisera son niveau de visibilité.
    C'est l'idée de masquer le fonctionnement exacte du mécanisme bien que je puisse utiliser ce mécanisme (idée de la grosse boite noire)
    public          | + | élement visible par tous
    protégé       | # | élément visible par les sous-classes de la classe
    privé           | -  | élément visible seulement par la classe
    paquetage   | ~ | élément encapsulé visible uniquement dans les classes du paquetage
    
    ex: 
        Personne                | |=&gt; classe
        --------------------------------
        -nom : chaine             | |
        -prenom : chaine         | |=&gt; attributs
        -dateNaissance : Date  | |
        -----------------------------------------------------------
        +calculeAge() : entier                             | |
        +getNom() : entier                                | | =&gt; methode
        +setDateNaissance(dateNaissance : Date) | |
        ------------------------------------------------------------      
        
        +getNom() est un accesseur en lecture/getter   
        +setDateNaissance est un accesseur en ecriture/mutateur/setter
        
</rich_text>
			<rich_text scale="h2">Propriétés de Classes</rich_text>
			<rich_text>
    Un attribut de classe est partagée avec sa valeur par l'ensemble des instances.
    Une méthode de classe est une méthode qui est directement liée à la classe elle-même.
    Au sein d'une telle méthode, seuls les attributs dits &quot;de classe' sont accessibles.
    Un attribut de classe est un attribut transverse partagé par toutes les instances (ex: TVA pour des produits en ventes, si ils ont la même TVA).
    
    ex: reprenant la classe Personne. l'attribut </rich_text>
			<rich_text underline="single">-majorite : int = 18</rich_text>
			<rich_text>. On la met en valeur en la soulignant.
    
    ex: en reprenant la classe Perssonne, une méthode de classe </rich_text>
			<rich_text underline="single">+changeMajorite(nouvelMajorite : entier)</rich_text>
			<rich_text>
    
</rich_text>
			<rich_text scale="h2">Généralisation/Spécialisation</rich_text>
			<rich_text>
    La généralisation/specialisation est une association particulière.
    Elle ne porte pas sur les instances mais sur les classes.
    Elle exprime que les instances d'une classe (classe fille) sont également des instances d'une autre classe (classe mère).
    La généralisation a pour but de factoriser des attributs et des méthodes communs à plusieurs classes.
    
    ex: on peut créer une classe spécialisé de personne : Salarié avec -salaire. Une autre Etudiant avec -note et -niveau.
            Personne        =&gt; </rich_text>
			<rich_text weight="heavy">classe mère / classe parente / superclasse</rich_text>
			<rich_text>
            ------------
                  |
            ------------   
            |          |
         Salarié   Etudiant =&gt; </rich_text>
			<rich_text weight="heavy">classes filles / classe dérivée / sous-classe</rich_text>
			<rich_text>
    
    </rich_text>
			<rich_text weight="heavy">Plus on remonte : généralisation. Plus on descent spécialisation.</rich_text>
			<rich_text>
    
    On peut creer des classes stériles qui ne peuvent avoir d'enfants.
    
</rich_text>
			<rich_text scale="h2">Héritage</rich_text>
			<rich_text>
    Les instances d'une sous-classe sont aussi instance de ses surclasses.
    Ces dernières sont donc également décrites par les attributs et méthodes introduites dans les surclasses.
    
    Par conséquent, une sous-classe hérite des attributs et des méthodes de sa sur-classe.
    Elle n'hérite que attributs et méthodes publiques (ou protégés : #) mais pas les publiques.
    
    Cet héritage provient de la relation Généralisation/Spécialisation.
    
</rich_text>
			<rich_text scale="h2">Polymorphisme</rich_text>
			<rich_text>
    Le polymorphisme s'inscrit dans une logique de Généralisation/Spécialisation.
    
    Le polymorphisme est le mécanisme qui consiste à appeler la méthode en fonction du type de l'objet instancié et non pas du type de l'objet réellement déclaré.
    
    ex:
        Salarié sal1;
        sal1.affiche(); =&gt; va chercher la méthode affiche() de la classe Salarié
        
        Personne p1;
        p1.affiche(); =&gt; va chercher la méthode affiche() de la classe Personne
        
        Personne TPers[3];
        tPers[0] &lt;- p1;     =&gt; possible car p1 est une Personne
        tPers[1] &lt;- sal1;   =&gt; possible car sal1 est une Personne
        tPers[0].affiche(); =&gt; va chercher la méthode affiche() de la classe Personne
        tPers[1].affiche(); =&gt; va chercher la méthode affiche() de la classe Salarié car on appelle le type de l'objet instancié (Salarié) par réellement déclaré (Personne)
        
</rich_text>
			<rich_text scale="h2">Classe abstraite</rich_text>
			<rich_text>
    Une classe “concréte” est une classe instanciable car elle décrit un modèle complet, tous les attributs et toutes les méthodes sont totalement décrits.
    
    Une classe abstraite provient de la “Généralisation”.
    
    Il s'agit d'une factorisation de propriétés communes.
    
    Une classe abstraite ne peut avoir d'instances directes.
    
    Les méthodes d'une classe abstraite peuvent être décrites de façon limitée à la signature de méthodes.
    On parle de “Méthode Abstraites”.
    
    ex:
        </rich_text>
			<rich_text style="italic">FormesGeo</rich_text>
			<rich_text>
        --------------------
        couleur : chaine
        --------------------
        Dessiner()          |=&gt; methode abstraite
        --------------------
         ^
         |
         |
        -----------------------------------------------------------
            |                       |                      |               
        Carré                   Triangle           Rectangle
       ------------------         ----------           --------------
       centre : Point          ...                  ...
       rayon : entier
       ------------------         -------------        ---------------
       Dessiner()              Dessiner()       Dessiner()
       
       Traditionnelement, on indique une classe abstraite en l'écrivant en italique.
       Ici la classe FormesGeo est abstraite (correspond à rien), mais permet de factoriser l'attribut couleur.
       
       Forcer à avoir une methode abstraite (donc vide) force a avoir la méthode Dessiner() défini dans les sous-classe.
       On garanti le </rich_text>
			<rich_text weight="heavy">polymorphisme</rich_text>
			<rich_text>.
       On impose un “schéma”.
       Si la sous-classe est elle aussi abstraite il n'est pas nécessaire de définir les méthode abstraite de la surclasse.
       
</rich_text>
			<rich_text scale="h2">Interface</rich_text>
			<rich_text>
    Une interface est une classe abstraite ne contenant que des signatures de méthode publiques.
    
    Une interface est réalisée par une classe.
    
    On dit qu'une classe implémente une interface.
    
    Une interface est employée pour décrire les fonctionnalités d'une classe ou d'un composant.
    
    C'est un élément fondamental de la conception objet.
    
    On indique formellement qu'une classe implémente une interface avec une flèche en pointillées ou le formalisme lollipop  Classe Interface ---O)--- Classe</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Ligne de Commande" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645426.55" ts_lastsave="1539073212.04" unique_id="3">
			<rich_text scale="h1">Prof. : ASSOUS Steeve

</rich_text>
			<rich_text scale="h2">Code : 2518</rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h1">Sommaire</rich_text>
			<rich_text>
    Présentation de Linux/Unix
    Système de fichiers : l'arborescence
    Manipulation de fichiers
    Edition de fichiers texte : VI
    Redirections et Filtres
    Recherche de Fichiers via “find”
    Rercherche de motifs “grep”
    Gestion des processus
    
</rich_text>
			<rich_text scale="h1">Présentation</rich_text>
			<rich_text>
</rich_text>
			<rich_text scale="h2">    
    Définition</rich_text>
			<rich_text>
        C'est un OS
            Programme ou ensemble de programmes et d'API, interface matériel et applications.
            
        Disponible pour de simple micro (PC, MAc, Atarie...) jusqu' au gros syst_me (IBM Z Series) et même dans des PDA
        
        Unix ? Linux ? Telle est la question.
        
</rich_text>
			<rich_text scale="h2">    Historique de UNIX</rich_text>
			<rich_text>
        1969 : Bell Laboratoire; Ken Thompson travaille sur MULTICS; Bell Lab abandonne le projet
                 K. Thomspon renomme UNICS et dev. sur DEC PDP-7
        1974 : refonte du syst. en language C; Unix gagne la fav. des univ.
        1978 : V7 annoncée
        1979 : cout des licences incite Berkley à continuer ses travaux. Création de BSD; le Darpa utilise BSD Unix
        1983 : AT&amp;T met en vente la version commercile de Unix Syst. V
        1984 : Wenix 1er Unix sur PC
        1991 : Apparation des premiers clones Unix comme Linux et FreeBSD
        1992 : Sun sort Solaris
        
    </rich_text>
			<rich_text scale="h2">D'où vient Linux ?</rich_text>
			<rich_text>
        1985 : création de la FSF par R. Stallman
            Copyleft et GPL avec 4 libertés fondamentales :
                exec. le programme pour tout usage commercial ou non et par n'importe quel type de personne ou d'organisation
                étudier le fonctionnement du pregramme et l'adapter 
                redistribuer des copies gratuitement ou non
                améliorer le programme et publier les améliorations
        1991 : création de Linux par Linus Torvald

    </rich_text>
			<rich_text scale="h2">Caractéristiques</rich_text>
			<rich_text>
        Unix/Linux est un OS :
            - multi-taches
            - multi-utilisateurs
            - multiplateformes
            - stable
            
        Les composants de base d'un Unix/Linux sont les noyau (kernel) et les outils (shell et commandes).
        
        L'OS a pour principales tâches les points suivants :
            - gestion de la mémoire
            - accès aux péréphériques
            - accès disque/ système de fichiers
            - gestion des programmes (processus)
            - sécuriité / accès aux données
            - collecte d'information système : statistiques
        
        LAMP pour les serveurs : Linux (OS) Apache (serveur Web) MySQL (SGBDR) PHP (language de programmation serveur).
        
    </rich_text>
			<rich_text scale="h2">Quelle distribution ?</rich_text>
			<rich_text>
        Le choix d'une distribution dépend de :
            - du cout
            - de la suite logicielle
            - de la compatibilité matérielle
            - des outils d'administration
            - mais aussi les préférences de chacun
        
        Les distributions “grands publics”
            - Fedora (distribué par Red Hat)
            - Open Suse
            - Mandriva (anciennement Mandrake)
            - Ubuntu
        
        Les distribution “pro.”
            Red Hat
            - Suse
            - Debian
            - Slackwave
       
        Les distributions “mobiles”
            - Knoppix
            - Mandriva Flash
            - Fedora Live CD
      
        Les distributions “spécialisées”
            - Tombsrbt
            - µLinux
        
    </rich_text>
			<rich_text scale="h2">Connexion : consoles et terminaux</rich_text>
			<rich_text>
        Chaque utilisateur sera doté d'un login et d'un MdP
            - root
            - règle de mot de passe

        La connexion peut se faire vie différentes manères
            - console virtuelle
               → Texte
               → Graphique
            - emulateur de terminaux
            - client ssh

    </rich_text>
			<rich_text scale="h2">Prompt (Invite shell)</rich_text>
			<rich_text>
          Le shell
              - interprétation en ligne des commandes
              - il traduit les requètes en actions
                
          Prompt : PS1
              - il s'agit de l'invite présente au moment de la saisie de'une commande
              - cette invite diffère suivant les environnements et suivant les utilisateurs
              
          ajc1@DebServ:~$
            - ajc1 : username
            - DebServ : hostname
            - ~ : repertoire de connexion (ici HOME)

    </rich_text>
			<rich_text scale="h2">La Documentation
</rich_text>
			<rich_text>            - man
            - info
            - option --help
            - internet :
               → </rich_text>
			<rich_text link="webs http://www.linux.org">www.linux.org</rich_text>
			<rich_text>
               → </rich_text>
			<rich_text link="webs http://www.tldp.org">www.tldp.org</rich_text>
			<rich_text>
               → </rich_text>
			<rich_text link="webs http://www.redhat.fr">www.redhat.fr</rich_text>
			<rich_text>
            - groupe de discution
        
</rich_text>
			<rich_text scale="h2">    Deconnexion
</rich_text>
			<rich_text>        Trois manières de se déconnecter d'un terminal texte :
            - exit
            - logout
            - ...

</rich_text>
			<rich_text scale="h2">    Quelques commandes</rich_text>
			<rich_text>
        Info utilisateur
            - who
            - whoami
            - passwd
       
        Affichage
            - clear
            - echo

        Temps
            - date
            - cal

</rich_text>
			<rich_text scale="h1">Système de Fichiers : Arborescence</rich_text>
			<rich_text>

    </rich_text>
			<rich_text scale="h2">Organisation</rich_text>
			<rich_text>
        Un syst. de fichiers (FileSystem) définit comment sont gérés les fichiers par l'OS
        
        Présenté de façon arborescente, le FS est une hiérarchie de répertoires ayant pour racine unique “/”
        
        Organisation logique et indépendante du stockage physique des données.
        Complétement transparente pour l'utilisateur.
        
        Diff. rep. :
            - bin : contient les commandes
            - boot : gere le demarage du système
            - cdrom : pour monter le cdrom
            - dev : contient les périphériques
            - etc : contient les fichiers de config
            - home : repertoire des utilisateurs
            - lib : contient les librairies
            - lost+found : garde les fichiers non correctement fermés en cas de crash
            - root : rep. du root
            - sbin : commande admin
            - tmp : fichiers temporaire
            - mnt : montage fichiers
            - proc : syst. de fichiers virtuel représentant l'etat actuel du syst.
            - sys : syst. de fichier vituels représentant l'état des différents peripheriques.
            - var : fichiers dont la taille vaire au cours de la vie du systeme
            - ...

    </rich_text>
			<rich_text scale="h2">“Tout est Fichier&quot; : nomenclatur</rich_text>
			<rich_text>e
        Unix fait la distinction entre min et maj.
        
        La plupart des caracs. (chiffres, lettres, maj. min. certains signes, caractères accentués) sont acceptés, y compris l'espace (déconseillé)
        
    </rich_text>
			<rich_text scale="h2">Adressage Absolut/Relatif</rich_text>
			<rich_text>
        Absolu : chemin identifié à partir de la racine
        
        Relatif : chemin défini à partir du répertoire courant
        
        Rep. :
            - courant : .
            - parent : ..
            - personnel : appelé aussi répertoire HOME
               → définit le rep. de connexion, l'espace personnel de l'utilisateur (/home/nomUser)

</rich_text>
			<rich_text scale="h2">    Manipulation de Fichiers/Répertoires</rich_text>
			<rich_text>
        Commandes permettant de manipuler les fichers
            - pwd : print working directory
            - cd : change directory
            - ls : liste le contenu du repertoire
               → ls -r : recursif
               → ls -1 : affiche sur une seule colonne
            - file : renvoie le type de fichier

        Répertoire
            - mkdir
            - rmdir

        Fichiers
            - touch
            - cp
            - rm
            - mv
            - cat
               → cat &gt; nomFichier : permet d'ecrire dans le fichier (attention efface ce qui est écrit)
               → cat &gt;&gt; nomFichier : écrit à la fin du fichier
            - more
            - head/tail : affiche les 10 premières/dernières lignes du fichier
               → head/tail -x : affiche les x premières/dernières lignes
            - cut : affiche une partie des lignes du/des fichier(s) en argument
               → La selection peut se faire par champ ou par caractères
               → cut -d: (délimiteur ici :) -f3 (champ ici 3)
               → cut -c1-8 (caractères de 1 a 8)
            - wc : comptabilise le nombre de lignes, mots, caractères
    
        ex :
        more /etc/passwd : affiche tous les utilisateurs inscrits
        ajc1:x:1151:1003::/home/ajc1:/bin/bash
        nomUser:PrésencePasseword:uid:gid:NomGECOS:RepertoireDeCMX:PossibilitéDeSeConnecter
        
        drwxr-xr-x 4 ajc1 unix 4096 oct 5 12:13 dos
            - d : type (d : directory, - : fichier ordinaire, l : lien symbolique, b: block, c : caractere)
            - rwxr-xr-x : permission User|Group|Other
            - 4 : nombre de lien physique
            - ajc1 : user proprietaire
            - unix : groupe propriétaire 
            - 4096
            - oct 5 12:13 : horodatage
            - dos : nom
        
        ls -l | cut -c1-10,41- : liste les fichiers avec détails | en ne gardant que les 10 premiers caractères puis les caractères à partir du 41e.
        
        wc fichHello : affiche le nombre de lignes, mots et caractères dans fichHello
        2 5 27 fichHello : 2 lignes, 5 mots, 27 caractères
        wc -l /etc/passwd : affiche le nombre de ligne dans /etc/passwd, correspond au nombres d'utilisateurs déclarés.

    </rich_text>
			<rich_text scale="h2">Permission</rich_text>
			<rich_text>
        rwx :
            - r : readable
            - w : writable
            - x : executable
            
        Pour un fichier normal :
            - r : contenu peut être lu, chargé en mémoire, visualisé, recopié
            - w : le contenu du fichier peut etre modifié, on peut écrire dedans. La suppression n'est pas forcément liée à ce droit (voir droit rep.)
            - x : le fichier peut etre executé depuis la ligne de commande, s'il s'agit soit d'un programme binaire (compilé), soit d'un script
           
        Pour un repertoire
            - r : 
            - w : droit de suppression
            - x : droit d'accès
            
        chmod : modifie les permissions 
            - chmod u+x : ajoute le droit d'executer à l'utilisateur
            - chmod g-w : retire au groupe le droit de lire
            - chmod og+x : ajoute au autres et au groupe le droit d'executer
            - chmod u=rwx : donne à l'utilisateur le droit de lire, écrire et executer
            - chmod a-x : retire à tout le monde le droit d'executer

        chmod peut aussi être utiliser avec une notation octale :
            - r : 4
            - w : 2
            - x : 1

</rich_text>
			<rich_text scale="h1">vi
</rich_text>
			<rich_text>    Editeur WYSIWYG
    Grand classique des editeurs de texte en entreprise
    
    </rich_text>
			<rich_text scale="h1">vi : mode de fonctionnement</rich_text>
			<rich_text>
        Jongler entre les différents modes : 
            - insertion : i, I, a, A, o, O
            - commande : echap 
            - ligne : ‘:’
        
        Pour sauvegarder ‘:wq’
        
    </rich_text>
			<rich_text scale="h3">Mode commande</rich_text>
			<rich_text>
        - nG : emmène à la ligne n (identique :n)
    
    </rich_text>
			<rich_text scale="h2">vi : Correction</rich_text>
			<rich_text>
        - x : efface le caractère sous le curseur
        - X : efface le caractère devant le curseur
        - re : remplace le caractère sous le curseur par le ‘e’
        - dw : efface le mot depuis le curseur jusqu'à la fin du mot
        - d$ : (ou D) efface tous les caracètres jusqu'à la fin de la ligne
        - dd : efface la ligne active
        - ndd : efface les n-lignes 
        - y/Y : copie la ligne
        - nY : copie n-lignes
        - p/P ; copie en dessous/au dessu de la ligne contenant le curseur
        
    </rich_text>
			<rich_text scale="h2">vi : mode ligne</rich_text>
			<rich_text>
        - :w : enregistre
        - :1,10w Nom_fich : enregistre les 10 premieres lignes
        - :r Nom_Fich : insère le fichier Nom_fich à partir de la ligne courante
        - :! commande : execute la commande puis retourne à l'editeur
        - :r ! commande : execute la commande et inscrit le resultat dans l'éditeur
        - :f Nom_fic : affiche en bas de l'écran le nom du fichier, nb de ligne et position actuel
        
    </rich_text>
			<rich_text scale="h2">vi : recherche et substitution</rich_text>
			<rich_text>
        Recherche :
            - on distingue deux facons de rechercher des chaines dans vi
               → / : recherche de haut en bas
               → ? : recherche de bas en haut

        Substitution :
            - :[1ere ligne, derniere ligne]s/Modèle/Remplacement/[gil]
               → :1,5/bin/sbin/
               → :5,30s/bach/ksh/g
               → 1,$s/fonction/function/gi
               → $ (ou %) jusqu'à la fin du fichier
               → g : toutes les occurentcs
               → i : insensible à la casse
               → I : sensible à la casse

    </rich_text>
			<rich_text scale="h2">vi : options</rich_text>
			<rich_text>
        Options de l'editeur
            - :set all : liste l'ensemble des options disponibles
            - :set number/nonumber : affiche/cache les numeros de lignes
            - :set autoident/noautoindent : l'indentation est conservée lors d'un retour de ligne
            - :set showmode/noshowmove : vi affiche une ligne d'état (montre le mode actuel)
            - :set tabstop=x : définit le nombre de caractères pour une tabulation
            - :set showmatch/noshowmatch : montre la parenthèse d'ouverture lors de la fermeture de cette dernière
            - ab DF DUPONT Franck : crée une abbréviation 
            - map x 10dd : mappage des touches

        Pour conserver les options il faut creer un fichiers specifique avec les options (.exrc).
        Commentaires avec &quot;
        
</rich_text>
			<rich_text scale="h1">Redirections et filtres</rich_text>
			<rich_text>
    Tout processus lancé est associé à 3 descripteurs (input, output, error)
    
    ex: ls 
            - entrée standard : dossier courant
            - sortie standard : écran
        mkdir rep
            - entrée standard : rep
            - sortie standard : écran
        cat &gt; f1
            - entrée standard saisie redirigée en sortieca vers f1

    ‘&gt;’ est un opérateur de redirection de même que ‘&gt;&gt;’ (mais lui redirige à la fin du fichier).    
    
    Opérateurs de filtre (pipe)
        - | : permet de lier des commandes. La 2eme commande est liée au résultat de la 1ere.  
     
</rich_text>
			<rich_text scale="h1">Find : prototype</rich_text>
			<rich_text>
        Permet de recherchers des fichiers
        
        </rich_text>
			<rich_text scale="h2">Find : critères de recherche</rich_text>
			<rich_text>
            au niveau du nom :
                - -name | iname motif
                    ex: $find . -name ‘nom’
                    
            au niveau du temps :
                - -mtime [+-] n (n jours) : modif de contenu
                - -atime [+-] n : acceder
                - ctime [+-] n : modif de contenu et/ou de caractéristiques
                    ex: $find . -atime -1
                    
            au niveau des caractéristiques :
                - -size [+-] taille [bck]
                - -user utilisateur
                - -group groupe
                - -type d|f|l|b|c : dossier|files|link|
                - -perm droits
                    ex : $ find / -user ‘as1’
                    
            Combiner des critères
                - et logique : -a ou -and
                - ou logique : -o ou -or
                - negation : -not ou !
                
            Exécution des commandes 
                - -print : affiche le nom des occurrences trouvés
                - -exec : execute la commande specifiée
                - -ok : reprend l'option -exec mais avec une demande de confirmation
                - -ls : affichage des resultats
                
                ex:
                - find . \(\(-name ‘D*’ -type d \) -o \( -name ‘rep*’ -type d \) \) -print
                - find . -name ‘*.sh' -exec cat {} \; : applique cat à chaque resultat du find.

</rich_text>
			<rich_text scale="h1">grep</rich_text>
			<rich_text>
    </rich_text>
			<rich_text scale="h2">grep : prototype</rich_text>
			<rich_text>
        Extraire des lignes d'un fichier selon divers critères.
        Pour cela on dispose de trois commandes grep, egrep et fgrep qui lisent les données soit depuis un fichier d'entrée soit depuis le canal d'entrée standard.
        
        grep  [-options] motif [arguments]
        
        Quelques options :
            - -v : affiche toutes les lignes qui ne correspondent pas au motif
            - -c : ne retourne pas les lignes mais leur nombres
            - -i : ne tient pas compte de la casse
            - -n : indique le numéro de ligne pour chaque ligne trouvée
            - -l : affiche le nom du fichier
    
    </rich_text>
			<rich_text scale="h2">grep : Expressions régulières</rich_text>
			<rich_text>
        Quelques métécaractères
            - ^ : début de ligne
            - . : un caractère quelconque
            - $ : fin de ligne
            - x* : zéro ou plus d'occurrences du caractère x
            - x+ : une ou plus occurences du caractères x
            - x? : 0 ou une occurence unique de x
            - [aX0] : classe de caractères permis
            - [.-.] : plage de caractères permis
            - [^...] : plage de caractères interdits
            - \{n,m\} : facteur d'occurrences
            - \ : caractère d'échappement
            - () : définit un groupe
            - | : ou

        ex: 
            - grep ‘^unix’ /etc/passwd : commence par unix
            - grep ‘[^0-9]$’ /etc/passwd : ne se termine pas par un chiffre
            - grep ‘^t(iti|oto|ata)’ nomFichier : commence par titi toto tata
            - grep ^0[1-9](\.[0-9]\{2\})\{4\} : recherche un numéro de téléphone 0x.yy.yy.yy.yy avec x 1-9 et y 0-9*

</rich_text>
			<rich_text scale="h2">Gestion des processus</rich_text>
			<rich_text>
    Un processus représente à la fois un programme en cours d'execution et tout son environnement d'écecution (mémoire, état, ..)
    
    Définit par :
        - un numéro de processus unique PID
        - un numéro de processu parent PPID
        - un numéro d'utilisateur et un numéroro de groupe
        - un répertoire de travail
        
    Daemons
        
    La commande ps affiche les processus en cours (ou pstree).
        - liste les processus du syst.
        - liste les processus de fachon hiérarchique
        
    Quelques options :
        -a : tous les utilisateurs
        -u : nom des utilisateurs et date
        -x : non rattaché à un terminal
        -l : informations détaillées
        
    Quelques colonnes :
        - UID
        - PID 
        - PPID
        - C : facteur de priorité (plus la valeur est grande plus la priorité est basse)
        -
        
    </rich_text>
			<rich_text scale="h2">Signaux et commande “kill”</rich_text>
			<rich_text>
        Le signal est l'un des moyens de communications entre les processus.
        Lorsqu'on envoie un signal à un processus, celui-ci doit l'intercepter et réagir en fonction de celui-ci.
        
        Certain signaux peuvent être ignorés, d'autres non.
        Suivant les UNIX; on dispose d'un nombre plus ou moins important de signaux.
        
        L'option -l permet d'obtenir la liste des signaux.
        
        Liste signaux :
            -1 SIGHUP : hang up, est envoyé par le père à tous ses enfants
            -5 SIGTRAP :
            -2 SIGINT : interruption du processus demandé (CTL+C)
            -3 SIGQUIT : idem SIGINT maig fénération d'un core dump (fichier débeuggage)
            -9 SIGKILL : signal ne pouvant être ignoré, force le processus à finir brutalement
            -15 SIGTERM : signal envoyé par défaut par la commande kill. Demande au processus de se terminer normalement

    </rich_text>
			<rich_text scale="h2">Manipulation processus</rich_text>
			<rich_text>
        Lancer un processus :
            - en avant-plan : on attend la fin de la commande avant de récuperer la main.
            - en arrière-plan : la commande se lance mais on ne perd pas la main. On utilise l'esperluette &amp;.
            - persistant : commande “nohup”
            - priorité : nice/renice
      
        Arreter un processus :
            - Ctrl + C : signal SIGINT 
            - Ctrl + \ : signal SIGQUIT
            - Ctrl + Z : signal SIGSTOP

        COntroler les processus
            - commande “jobs” : affiche la liste des processus lancés en arrière plan
            - commande “bg” : relance un processus suspendu en arrière plan
            - comme “fg” : lance un processus en avant-plan      
     


      </rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Shell" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645440.47" ts_lastsave="1539071886.68" unique_id="4">
			<rich_text scale="h1">Prof. : ASSOUS Steeve

</rich_text>
			<rich_text scale="h2">Code : 4826</rich_text>
			<rich_text>

</rich_text>
			<rich_text scale="h1">Sommaire :</rich_text>
			<rich_text>


Gestion des processus :</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Role et Comportement du Consultant" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645450.69" ts_lastsave="1538645450.69" unique_id="5">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Red Hat System Administration" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645474.36" ts_lastsave="1538645474.36" unique_id="6">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Installation et Configuration de Microsoft Windows Server 2012" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645502.64" ts_lastsave="1538645502.64" unique_id="7">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Savoir se Présenter, les Nouvelles Compétences Acquises" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645530.48" ts_lastsave="1538645530.48" unique_id="8">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="PowerShell" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645537.14" ts_lastsave="1538645543.78" unique_id="9">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Programmation Python" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645543.78" ts_lastsave="1538645565.36" unique_id="10">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Cloud" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645547.45" ts_lastsave="1538645568.11" unique_id="11">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="L'Ingenieurie DevOps sur Amazon Web Services" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645562.11" ts_lastsave="1538645570.81" unique_id="12">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Oracle SQL et Exploitation" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645583.16" ts_lastsave="1538645583.16" unique_id="13">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="DevOps" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645587.36" ts_lastsave="1538645587.36" unique_id="14">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Docker" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645591.75" ts_lastsave="1538645591.75" unique_id="15">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Jenkins" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645595.9" ts_lastsave="1538645595.9" unique_id="16">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Ansible" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645599.95" ts_lastsave="1538645599.95" unique_id="17">
			<rich_text></rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Puppet" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538645605.17" ts_lastsave="1538645605.17" unique_id="18">
			<rich_text></rich_text>
		</node>
	</node>
</cherrytree>
